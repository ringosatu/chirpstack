// This file is @generated by prost-build.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Any {
    #[prost(string, tag = "1")]
    pub type_url: ::prost::alloc::string::String,
    #[prost(bytes = "bytes", tag = "2")]
    pub value: ::prost::bytes::Bytes,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SourceContext {
    #[prost(string, tag = "1")]
    pub file_name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Type {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    #[prost(string, repeated, tag = "3")]
    pub oneofs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<Option>,
    #[prost(message, optional, tag = "5")]
    pub source_context: ::core::option::Option<SourceContext>,
    #[prost(enumeration = "Syntax", tag = "6")]
    pub syntax: i32,
    #[prost(string, tag = "7")]
    pub edition: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(enumeration = "field::Kind", tag = "1")]
    pub kind: i32,
    #[prost(enumeration = "field::Cardinality", tag = "2")]
    pub cardinality: i32,
    #[prost(int32, tag = "3")]
    pub number: i32,
    #[prost(string, tag = "4")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "6")]
    pub type_url: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub oneof_index: i32,
    #[prost(bool, tag = "8")]
    pub packed: bool,
    #[prost(message, repeated, tag = "9")]
    pub options: ::prost::alloc::vec::Vec<Option>,
    #[prost(string, tag = "10")]
    pub json_name: ::prost::alloc::string::String,
    #[prost(string, tag = "11")]
    pub default_value: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Field`.
pub mod field {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        TypeUnknown = 0,
        TypeDouble = 1,
        TypeFloat = 2,
        TypeInt64 = 3,
        TypeUint64 = 4,
        TypeInt32 = 5,
        TypeFixed64 = 6,
        TypeFixed32 = 7,
        TypeBool = 8,
        TypeString = 9,
        TypeGroup = 10,
        TypeMessage = 11,
        TypeBytes = 12,
        TypeUint32 = 13,
        TypeEnum = 14,
        TypeSfixed32 = 15,
        TypeSfixed64 = 16,
        TypeSint32 = 17,
        TypeSint64 = 18,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TypeUnknown => "TYPE_UNKNOWN",
                Self::TypeDouble => "TYPE_DOUBLE",
                Self::TypeFloat => "TYPE_FLOAT",
                Self::TypeInt64 => "TYPE_INT64",
                Self::TypeUint64 => "TYPE_UINT64",
                Self::TypeInt32 => "TYPE_INT32",
                Self::TypeFixed64 => "TYPE_FIXED64",
                Self::TypeFixed32 => "TYPE_FIXED32",
                Self::TypeBool => "TYPE_BOOL",
                Self::TypeString => "TYPE_STRING",
                Self::TypeGroup => "TYPE_GROUP",
                Self::TypeMessage => "TYPE_MESSAGE",
                Self::TypeBytes => "TYPE_BYTES",
                Self::TypeUint32 => "TYPE_UINT32",
                Self::TypeEnum => "TYPE_ENUM",
                Self::TypeSfixed32 => "TYPE_SFIXED32",
                Self::TypeSfixed64 => "TYPE_SFIXED64",
                Self::TypeSint32 => "TYPE_SINT32",
                Self::TypeSint64 => "TYPE_SINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNKNOWN" => Some(Self::TypeUnknown),
                "TYPE_DOUBLE" => Some(Self::TypeDouble),
                "TYPE_FLOAT" => Some(Self::TypeFloat),
                "TYPE_INT64" => Some(Self::TypeInt64),
                "TYPE_UINT64" => Some(Self::TypeUint64),
                "TYPE_INT32" => Some(Self::TypeInt32),
                "TYPE_FIXED64" => Some(Self::TypeFixed64),
                "TYPE_FIXED32" => Some(Self::TypeFixed32),
                "TYPE_BOOL" => Some(Self::TypeBool),
                "TYPE_STRING" => Some(Self::TypeString),
                "TYPE_GROUP" => Some(Self::TypeGroup),
                "TYPE_MESSAGE" => Some(Self::TypeMessage),
                "TYPE_BYTES" => Some(Self::TypeBytes),
                "TYPE_UINT32" => Some(Self::TypeUint32),
                "TYPE_ENUM" => Some(Self::TypeEnum),
                "TYPE_SFIXED32" => Some(Self::TypeSfixed32),
                "TYPE_SFIXED64" => Some(Self::TypeSfixed64),
                "TYPE_SINT32" => Some(Self::TypeSint32),
                "TYPE_SINT64" => Some(Self::TypeSint64),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Cardinality {
        Unknown = 0,
        Optional = 1,
        Required = 2,
        Repeated = 3,
    }
    impl Cardinality {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "CARDINALITY_UNKNOWN",
                Self::Optional => "CARDINALITY_OPTIONAL",
                Self::Required => "CARDINALITY_REQUIRED",
                Self::Repeated => "CARDINALITY_REPEATED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "CARDINALITY_UNKNOWN" => Some(Self::Unknown),
                "CARDINALITY_OPTIONAL" => Some(Self::Optional),
                "CARDINALITY_REQUIRED" => Some(Self::Required),
                "CARDINALITY_REPEATED" => Some(Self::Repeated),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Enum {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub enumvalue: ::prost::alloc::vec::Vec<EnumValue>,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Option>,
    #[prost(message, optional, tag = "4")]
    pub source_context: ::core::option::Option<SourceContext>,
    #[prost(enumeration = "Syntax", tag = "5")]
    pub syntax: i32,
    #[prost(string, tag = "6")]
    pub edition: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValue {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub number: i32,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Option>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Option {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Any>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Syntax {
    Proto2 = 0,
    Proto3 = 1,
    Editions = 2,
}
impl Syntax {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Proto2 => "SYNTAX_PROTO2",
            Self::Proto3 => "SYNTAX_PROTO3",
            Self::Editions => "SYNTAX_EDITIONS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SYNTAX_PROTO2" => Some(Self::Proto2),
            "SYNTAX_PROTO3" => Some(Self::Proto3),
            "SYNTAX_EDITIONS" => Some(Self::Editions),
            _ => None,
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Api {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub methods: ::prost::alloc::vec::Vec<Method>,
    #[prost(message, repeated, tag = "3")]
    pub options: ::prost::alloc::vec::Vec<Option>,
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "5")]
    pub source_context: ::core::option::Option<SourceContext>,
    #[prost(message, repeated, tag = "6")]
    pub mixins: ::prost::alloc::vec::Vec<Mixin>,
    #[prost(enumeration = "Syntax", tag = "7")]
    pub syntax: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Method {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub request_type_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "3")]
    pub request_streaming: bool,
    #[prost(string, tag = "4")]
    pub response_type_url: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub response_streaming: bool,
    #[prost(message, repeated, tag = "6")]
    pub options: ::prost::alloc::vec::Vec<Option>,
    #[prost(enumeration = "Syntax", tag = "7")]
    pub syntax: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Mixin {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub root: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDescriptorSet {
    #[prost(message, repeated, tag = "1")]
    pub file: ::prost::alloc::vec::Vec<FileDescriptorProto>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub package: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub dependency: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int32, repeated, packed = "false", tag = "10")]
    pub public_dependency: ::prost::alloc::vec::Vec<i32>,
    #[prost(int32, repeated, packed = "false", tag = "11")]
    pub weak_dependency: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "4")]
    pub message_type: ::prost::alloc::vec::Vec<DescriptorProto>,
    #[prost(message, repeated, tag = "5")]
    pub enum_type: ::prost::alloc::vec::Vec<EnumDescriptorProto>,
    #[prost(message, repeated, tag = "6")]
    pub service: ::prost::alloc::vec::Vec<ServiceDescriptorProto>,
    #[prost(message, repeated, tag = "7")]
    pub extension: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
    #[prost(message, optional, tag = "8")]
    pub options: ::core::option::Option<FileOptions>,
    #[prost(message, optional, tag = "9")]
    pub source_code_info: ::core::option::Option<SourceCodeInfo>,
    #[prost(string, optional, tag = "12")]
    pub syntax: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "Edition", optional, tag = "14")]
    pub edition: ::core::option::Option<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub field: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
    #[prost(message, repeated, tag = "6")]
    pub extension: ::prost::alloc::vec::Vec<FieldDescriptorProto>,
    #[prost(message, repeated, tag = "3")]
    pub nested_type: ::prost::alloc::vec::Vec<DescriptorProto>,
    #[prost(message, repeated, tag = "4")]
    pub enum_type: ::prost::alloc::vec::Vec<EnumDescriptorProto>,
    #[prost(message, repeated, tag = "5")]
    pub extension_range: ::prost::alloc::vec::Vec<descriptor_proto::ExtensionRange>,
    #[prost(message, repeated, tag = "8")]
    pub oneof_decl: ::prost::alloc::vec::Vec<OneofDescriptorProto>,
    #[prost(message, optional, tag = "7")]
    pub options: ::core::option::Option<MessageOptions>,
    #[prost(message, repeated, tag = "9")]
    pub reserved_range: ::prost::alloc::vec::Vec<descriptor_proto::ReservedRange>,
    #[prost(string, repeated, tag = "10")]
    pub reserved_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `DescriptorProto`.
pub mod descriptor_proto {
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ExtensionRange {
        #[prost(int32, optional, tag = "1")]
        pub start: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub end: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "3")]
        pub options: ::core::option::Option<super::ExtensionRangeOptions>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct ReservedRange {
        #[prost(int32, optional, tag = "1")]
        pub start: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub end: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExtensionRangeOptions {
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
    #[prost(message, repeated, tag = "2")]
    pub declaration: ::prost::alloc::vec::Vec<extension_range_options::Declaration>,
    #[prost(message, optional, tag = "50")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(
        enumeration = "extension_range_options::VerificationState",
        optional,
        tag = "3",
        default = "Unverified"
    )]
    pub verification: ::core::option::Option<i32>,
}
/// Nested message and enum types in `ExtensionRangeOptions`.
pub mod extension_range_options {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Declaration {
        #[prost(int32, optional, tag = "1")]
        pub number: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub full_name: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "3")]
        pub r#type: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(bool, optional, tag = "5")]
        pub reserved: ::core::option::Option<bool>,
        #[prost(bool, optional, tag = "6")]
        pub repeated: ::core::option::Option<bool>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum VerificationState {
        Declaration = 0,
        Unverified = 1,
    }
    impl VerificationState {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Declaration => "DECLARATION",
                Self::Unverified => "UNVERIFIED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "DECLARATION" => Some(Self::Declaration),
                "UNVERIFIED" => Some(Self::Unverified),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "3")]
    pub number: ::core::option::Option<i32>,
    #[prost(enumeration = "field_descriptor_proto::Label", optional, tag = "4")]
    pub label: ::core::option::Option<i32>,
    #[prost(enumeration = "field_descriptor_proto::Type", optional, tag = "5")]
    pub r#type: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "6")]
    pub type_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub extendee: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub default_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "9")]
    pub oneof_index: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "10")]
    pub json_name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "8")]
    pub options: ::core::option::Option<FieldOptions>,
    #[prost(bool, optional, tag = "17")]
    pub proto3_optional: ::core::option::Option<bool>,
}
/// Nested message and enum types in `FieldDescriptorProto`.
pub mod field_descriptor_proto {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Double = 1,
        Float = 2,
        Int64 = 3,
        Uint64 = 4,
        Int32 = 5,
        Fixed64 = 6,
        Fixed32 = 7,
        Bool = 8,
        String = 9,
        Group = 10,
        Message = 11,
        Bytes = 12,
        Uint32 = 13,
        Enum = 14,
        Sfixed32 = 15,
        Sfixed64 = 16,
        Sint32 = 17,
        Sint64 = 18,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Double => "TYPE_DOUBLE",
                Self::Float => "TYPE_FLOAT",
                Self::Int64 => "TYPE_INT64",
                Self::Uint64 => "TYPE_UINT64",
                Self::Int32 => "TYPE_INT32",
                Self::Fixed64 => "TYPE_FIXED64",
                Self::Fixed32 => "TYPE_FIXED32",
                Self::Bool => "TYPE_BOOL",
                Self::String => "TYPE_STRING",
                Self::Group => "TYPE_GROUP",
                Self::Message => "TYPE_MESSAGE",
                Self::Bytes => "TYPE_BYTES",
                Self::Uint32 => "TYPE_UINT32",
                Self::Enum => "TYPE_ENUM",
                Self::Sfixed32 => "TYPE_SFIXED32",
                Self::Sfixed64 => "TYPE_SFIXED64",
                Self::Sint32 => "TYPE_SINT32",
                Self::Sint64 => "TYPE_SINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_DOUBLE" => Some(Self::Double),
                "TYPE_FLOAT" => Some(Self::Float),
                "TYPE_INT64" => Some(Self::Int64),
                "TYPE_UINT64" => Some(Self::Uint64),
                "TYPE_INT32" => Some(Self::Int32),
                "TYPE_FIXED64" => Some(Self::Fixed64),
                "TYPE_FIXED32" => Some(Self::Fixed32),
                "TYPE_BOOL" => Some(Self::Bool),
                "TYPE_STRING" => Some(Self::String),
                "TYPE_GROUP" => Some(Self::Group),
                "TYPE_MESSAGE" => Some(Self::Message),
                "TYPE_BYTES" => Some(Self::Bytes),
                "TYPE_UINT32" => Some(Self::Uint32),
                "TYPE_ENUM" => Some(Self::Enum),
                "TYPE_SFIXED32" => Some(Self::Sfixed32),
                "TYPE_SFIXED64" => Some(Self::Sfixed64),
                "TYPE_SINT32" => Some(Self::Sint32),
                "TYPE_SINT64" => Some(Self::Sint64),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Label {
        Optional = 1,
        Repeated = 3,
        Required = 2,
    }
    impl Label {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Optional => "LABEL_OPTIONAL",
                Self::Repeated => "LABEL_REPEATED",
                Self::Required => "LABEL_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "LABEL_OPTIONAL" => Some(Self::Optional),
                "LABEL_REPEATED" => Some(Self::Repeated),
                "LABEL_REQUIRED" => Some(Self::Required),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneofDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub options: ::core::option::Option<OneofOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub value: ::prost::alloc::vec::Vec<EnumValueDescriptorProto>,
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<EnumOptions>,
    #[prost(message, repeated, tag = "4")]
    pub reserved_range: ::prost::alloc::vec::Vec<
        enum_descriptor_proto::EnumReservedRange,
    >,
    #[prost(string, repeated, tag = "5")]
    pub reserved_name: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Nested message and enum types in `EnumDescriptorProto`.
pub mod enum_descriptor_proto {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EnumReservedRange {
        #[prost(int32, optional, tag = "1")]
        pub start: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "2")]
        pub end: ::core::option::Option<i32>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValueDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(int32, optional, tag = "2")]
    pub number: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<EnumValueOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "2")]
    pub method: ::prost::alloc::vec::Vec<MethodDescriptorProto>,
    #[prost(message, optional, tag = "3")]
    pub options: ::core::option::Option<ServiceOptions>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MethodDescriptorProto {
    #[prost(string, optional, tag = "1")]
    pub name: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "2")]
    pub input_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub output_type: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "4")]
    pub options: ::core::option::Option<MethodOptions>,
    #[prost(bool, optional, tag = "5", default = "false")]
    pub client_streaming: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "6", default = "false")]
    pub server_streaming: ::core::option::Option<bool>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileOptions {
    #[prost(string, optional, tag = "1")]
    pub java_package: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub java_outer_classname: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "10", default = "false")]
    pub java_multiple_files: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(bool, optional, tag = "20")]
    pub java_generate_equals_and_hash: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "27", default = "false")]
    pub java_string_check_utf8: ::core::option::Option<bool>,
    #[prost(
        enumeration = "file_options::OptimizeMode",
        optional,
        tag = "9",
        default = "Speed"
    )]
    pub optimize_for: ::core::option::Option<i32>,
    #[prost(string, optional, tag = "11")]
    pub go_package: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bool, optional, tag = "16", default = "false")]
    pub cc_generic_services: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "17", default = "false")]
    pub java_generic_services: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "18", default = "false")]
    pub py_generic_services: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "23", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "31", default = "true")]
    pub cc_enable_arenas: ::core::option::Option<bool>,
    #[prost(string, optional, tag = "36")]
    pub objc_class_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "37")]
    pub csharp_namespace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "39")]
    pub swift_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "40")]
    pub php_class_prefix: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "41")]
    pub php_namespace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "44")]
    pub php_metadata_namespace: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "45")]
    pub ruby_package: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "50")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
/// Nested message and enum types in `FileOptions`.
pub mod file_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptimizeMode {
        Speed = 1,
        CodeSize = 2,
        LiteRuntime = 3,
    }
    impl OptimizeMode {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Speed => "SPEED",
                Self::CodeSize => "CODE_SIZE",
                Self::LiteRuntime => "LITE_RUNTIME",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPEED" => Some(Self::Speed),
                "CODE_SIZE" => Some(Self::CodeSize),
                "LITE_RUNTIME" => Some(Self::LiteRuntime),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MessageOptions {
    #[prost(bool, optional, tag = "1", default = "false")]
    pub message_set_wire_format: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "2", default = "false")]
    pub no_standard_descriptor_accessor: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "7")]
    pub map_entry: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(bool, optional, tag = "11")]
    pub deprecated_legacy_json_field_conflicts: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "12")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FieldOptions {
    #[prost(
        enumeration = "field_options::CType",
        optional,
        tag = "1",
        default = "String"
    )]
    pub ctype: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "2")]
    pub packed: ::core::option::Option<bool>,
    #[prost(
        enumeration = "field_options::JsType",
        optional,
        tag = "6",
        default = "JsNormal"
    )]
    pub jstype: ::core::option::Option<i32>,
    #[prost(bool, optional, tag = "5", default = "false")]
    pub lazy: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "15", default = "false")]
    pub unverified_lazy: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "10", default = "false")]
    pub weak: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "16", default = "false")]
    pub debug_redact: ::core::option::Option<bool>,
    #[prost(enumeration = "field_options::OptionRetention", optional, tag = "17")]
    pub retention: ::core::option::Option<i32>,
    #[prost(
        enumeration = "field_options::OptionTargetType",
        repeated,
        packed = "false",
        tag = "19"
    )]
    pub targets: ::prost::alloc::vec::Vec<i32>,
    #[prost(message, repeated, tag = "20")]
    pub edition_defaults: ::prost::alloc::vec::Vec<field_options::EditionDefault>,
    #[prost(message, optional, tag = "21")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, optional, tag = "22")]
    pub feature_support: ::core::option::Option<field_options::FeatureSupport>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
/// Nested message and enum types in `FieldOptions`.
pub mod field_options {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct EditionDefault {
        #[prost(enumeration = "super::Edition", optional, tag = "3")]
        pub edition: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "2")]
        pub value: ::core::option::Option<::prost::alloc::string::String>,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FeatureSupport {
        #[prost(enumeration = "super::Edition", optional, tag = "1")]
        pub edition_introduced: ::core::option::Option<i32>,
        #[prost(enumeration = "super::Edition", optional, tag = "2")]
        pub edition_deprecated: ::core::option::Option<i32>,
        #[prost(string, optional, tag = "3")]
        pub deprecation_warning: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(enumeration = "super::Edition", optional, tag = "4")]
        pub edition_removed: ::core::option::Option<i32>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum CType {
        String = 0,
        Cord = 1,
        StringPiece = 2,
    }
    impl CType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::String => "STRING",
                Self::Cord => "CORD",
                Self::StringPiece => "STRING_PIECE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRING" => Some(Self::String),
                "CORD" => Some(Self::Cord),
                "STRING_PIECE" => Some(Self::StringPiece),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JsType {
        JsNormal = 0,
        JsString = 1,
        JsNumber = 2,
    }
    impl JsType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::JsNormal => "JS_NORMAL",
                Self::JsString => "JS_STRING",
                Self::JsNumber => "JS_NUMBER",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JS_NORMAL" => Some(Self::JsNormal),
                "JS_STRING" => Some(Self::JsString),
                "JS_NUMBER" => Some(Self::JsNumber),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionRetention {
        RetentionUnknown = 0,
        RetentionRuntime = 1,
        RetentionSource = 2,
    }
    impl OptionRetention {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::RetentionUnknown => "RETENTION_UNKNOWN",
                Self::RetentionRuntime => "RETENTION_RUNTIME",
                Self::RetentionSource => "RETENTION_SOURCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "RETENTION_UNKNOWN" => Some(Self::RetentionUnknown),
                "RETENTION_RUNTIME" => Some(Self::RetentionRuntime),
                "RETENTION_SOURCE" => Some(Self::RetentionSource),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum OptionTargetType {
        TargetTypeUnknown = 0,
        TargetTypeFile = 1,
        TargetTypeExtensionRange = 2,
        TargetTypeMessage = 3,
        TargetTypeField = 4,
        TargetTypeOneof = 5,
        TargetTypeEnum = 6,
        TargetTypeEnumEntry = 7,
        TargetTypeService = 8,
        TargetTypeMethod = 9,
    }
    impl OptionTargetType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::TargetTypeUnknown => "TARGET_TYPE_UNKNOWN",
                Self::TargetTypeFile => "TARGET_TYPE_FILE",
                Self::TargetTypeExtensionRange => "TARGET_TYPE_EXTENSION_RANGE",
                Self::TargetTypeMessage => "TARGET_TYPE_MESSAGE",
                Self::TargetTypeField => "TARGET_TYPE_FIELD",
                Self::TargetTypeOneof => "TARGET_TYPE_ONEOF",
                Self::TargetTypeEnum => "TARGET_TYPE_ENUM",
                Self::TargetTypeEnumEntry => "TARGET_TYPE_ENUM_ENTRY",
                Self::TargetTypeService => "TARGET_TYPE_SERVICE",
                Self::TargetTypeMethod => "TARGET_TYPE_METHOD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TARGET_TYPE_UNKNOWN" => Some(Self::TargetTypeUnknown),
                "TARGET_TYPE_FILE" => Some(Self::TargetTypeFile),
                "TARGET_TYPE_EXTENSION_RANGE" => Some(Self::TargetTypeExtensionRange),
                "TARGET_TYPE_MESSAGE" => Some(Self::TargetTypeMessage),
                "TARGET_TYPE_FIELD" => Some(Self::TargetTypeField),
                "TARGET_TYPE_ONEOF" => Some(Self::TargetTypeOneof),
                "TARGET_TYPE_ENUM" => Some(Self::TargetTypeEnum),
                "TARGET_TYPE_ENUM_ENTRY" => Some(Self::TargetTypeEnumEntry),
                "TARGET_TYPE_SERVICE" => Some(Self::TargetTypeService),
                "TARGET_TYPE_METHOD" => Some(Self::TargetTypeMethod),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OneofOptions {
    #[prost(message, optional, tag = "1")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumOptions {
    #[prost(bool, optional, tag = "2")]
    pub allow_alias: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[deprecated]
    #[prost(bool, optional, tag = "6")]
    pub deprecated_legacy_json_field_conflicts: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "7")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EnumValueOptions {
    #[prost(bool, optional, tag = "1", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "2")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(bool, optional, tag = "3", default = "false")]
    pub debug_redact: ::core::option::Option<bool>,
    #[prost(message, optional, tag = "4")]
    pub feature_support: ::core::option::Option<field_options::FeatureSupport>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceOptions {
    #[prost(message, optional, tag = "34")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(bool, optional, tag = "33", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MethodOptions {
    #[prost(bool, optional, tag = "33", default = "false")]
    pub deprecated: ::core::option::Option<bool>,
    #[prost(
        enumeration = "method_options::IdempotencyLevel",
        optional,
        tag = "34",
        default = "IdempotencyUnknown"
    )]
    pub idempotency_level: ::core::option::Option<i32>,
    #[prost(message, optional, tag = "35")]
    pub features: ::core::option::Option<FeatureSet>,
    #[prost(message, repeated, tag = "999")]
    pub uninterpreted_option: ::prost::alloc::vec::Vec<UninterpretedOption>,
}
/// Nested message and enum types in `MethodOptions`.
pub mod method_options {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum IdempotencyLevel {
        IdempotencyUnknown = 0,
        NoSideEffects = 1,
        Idempotent = 2,
    }
    impl IdempotencyLevel {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::IdempotencyUnknown => "IDEMPOTENCY_UNKNOWN",
                Self::NoSideEffects => "NO_SIDE_EFFECTS",
                Self::Idempotent => "IDEMPOTENT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "IDEMPOTENCY_UNKNOWN" => Some(Self::IdempotencyUnknown),
                "NO_SIDE_EFFECTS" => Some(Self::NoSideEffects),
                "IDEMPOTENT" => Some(Self::Idempotent),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UninterpretedOption {
    #[prost(message, repeated, tag = "2")]
    pub name: ::prost::alloc::vec::Vec<uninterpreted_option::NamePart>,
    #[prost(string, optional, tag = "3")]
    pub identifier_value: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(uint64, optional, tag = "4")]
    pub positive_int_value: ::core::option::Option<u64>,
    #[prost(int64, optional, tag = "5")]
    pub negative_int_value: ::core::option::Option<i64>,
    #[prost(double, optional, tag = "6")]
    pub double_value: ::core::option::Option<f64>,
    #[prost(bytes = "bytes", optional, tag = "7")]
    pub string_value: ::core::option::Option<::prost::bytes::Bytes>,
    #[prost(string, optional, tag = "8")]
    pub aggregate_value: ::core::option::Option<::prost::alloc::string::String>,
}
/// Nested message and enum types in `UninterpretedOption`.
pub mod uninterpreted_option {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct NamePart {
        #[prost(string, required, tag = "1")]
        pub name_part: ::prost::alloc::string::String,
        #[prost(bool, required, tag = "2")]
        pub is_extension: bool,
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FeatureSet {
    #[prost(enumeration = "feature_set::FieldPresence", optional, tag = "1")]
    pub field_presence: ::core::option::Option<i32>,
    #[prost(enumeration = "feature_set::EnumType", optional, tag = "2")]
    pub enum_type: ::core::option::Option<i32>,
    #[prost(enumeration = "feature_set::RepeatedFieldEncoding", optional, tag = "3")]
    pub repeated_field_encoding: ::core::option::Option<i32>,
    #[prost(enumeration = "feature_set::Utf8Validation", optional, tag = "4")]
    pub utf8_validation: ::core::option::Option<i32>,
    #[prost(enumeration = "feature_set::MessageEncoding", optional, tag = "5")]
    pub message_encoding: ::core::option::Option<i32>,
    #[prost(enumeration = "feature_set::JsonFormat", optional, tag = "6")]
    pub json_format: ::core::option::Option<i32>,
}
/// Nested message and enum types in `FeatureSet`.
pub mod feature_set {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum FieldPresence {
        Unknown = 0,
        Explicit = 1,
        Implicit = 2,
        LegacyRequired = 3,
    }
    impl FieldPresence {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "FIELD_PRESENCE_UNKNOWN",
                Self::Explicit => "EXPLICIT",
                Self::Implicit => "IMPLICIT",
                Self::LegacyRequired => "LEGACY_REQUIRED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "FIELD_PRESENCE_UNKNOWN" => Some(Self::Unknown),
                "EXPLICIT" => Some(Self::Explicit),
                "IMPLICIT" => Some(Self::Implicit),
                "LEGACY_REQUIRED" => Some(Self::LegacyRequired),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum EnumType {
        Unknown = 0,
        Open = 1,
        Closed = 2,
    }
    impl EnumType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "ENUM_TYPE_UNKNOWN",
                Self::Open => "OPEN",
                Self::Closed => "CLOSED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ENUM_TYPE_UNKNOWN" => Some(Self::Unknown),
                "OPEN" => Some(Self::Open),
                "CLOSED" => Some(Self::Closed),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum RepeatedFieldEncoding {
        Unknown = 0,
        Packed = 1,
        Expanded = 2,
    }
    impl RepeatedFieldEncoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "REPEATED_FIELD_ENCODING_UNKNOWN",
                Self::Packed => "PACKED",
                Self::Expanded => "EXPANDED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "REPEATED_FIELD_ENCODING_UNKNOWN" => Some(Self::Unknown),
                "PACKED" => Some(Self::Packed),
                "EXPANDED" => Some(Self::Expanded),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Utf8Validation {
        Unknown = 0,
        Verify = 2,
        None = 3,
    }
    impl Utf8Validation {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "UTF8_VALIDATION_UNKNOWN",
                Self::Verify => "VERIFY",
                Self::None => "NONE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UTF8_VALIDATION_UNKNOWN" => Some(Self::Unknown),
                "VERIFY" => Some(Self::Verify),
                "NONE" => Some(Self::None),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum MessageEncoding {
        Unknown = 0,
        LengthPrefixed = 1,
        Delimited = 2,
    }
    impl MessageEncoding {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "MESSAGE_ENCODING_UNKNOWN",
                Self::LengthPrefixed => "LENGTH_PREFIXED",
                Self::Delimited => "DELIMITED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "MESSAGE_ENCODING_UNKNOWN" => Some(Self::Unknown),
                "LENGTH_PREFIXED" => Some(Self::LengthPrefixed),
                "DELIMITED" => Some(Self::Delimited),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum JsonFormat {
        Unknown = 0,
        Allow = 1,
        LegacyBestEffort = 2,
    }
    impl JsonFormat {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unknown => "JSON_FORMAT_UNKNOWN",
                Self::Allow => "ALLOW",
                Self::LegacyBestEffort => "LEGACY_BEST_EFFORT",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "JSON_FORMAT_UNKNOWN" => Some(Self::Unknown),
                "ALLOW" => Some(Self::Allow),
                "LEGACY_BEST_EFFORT" => Some(Self::LegacyBestEffort),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FeatureSetDefaults {
    #[prost(message, repeated, tag = "1")]
    pub defaults: ::prost::alloc::vec::Vec<
        feature_set_defaults::FeatureSetEditionDefault,
    >,
    #[prost(enumeration = "Edition", optional, tag = "4")]
    pub minimum_edition: ::core::option::Option<i32>,
    #[prost(enumeration = "Edition", optional, tag = "5")]
    pub maximum_edition: ::core::option::Option<i32>,
}
/// Nested message and enum types in `FeatureSetDefaults`.
pub mod feature_set_defaults {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct FeatureSetEditionDefault {
        #[prost(enumeration = "super::Edition", optional, tag = "3")]
        pub edition: ::core::option::Option<i32>,
        #[prost(message, optional, tag = "4")]
        pub overridable_features: ::core::option::Option<super::FeatureSet>,
        #[prost(message, optional, tag = "5")]
        pub fixed_features: ::core::option::Option<super::FeatureSet>,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SourceCodeInfo {
    #[prost(message, repeated, tag = "1")]
    pub location: ::prost::alloc::vec::Vec<source_code_info::Location>,
}
/// Nested message and enum types in `SourceCodeInfo`.
pub mod source_code_info {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Location {
        #[prost(int32, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<i32>,
        #[prost(int32, repeated, tag = "2")]
        pub span: ::prost::alloc::vec::Vec<i32>,
        #[prost(string, optional, tag = "3")]
        pub leading_comments: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, optional, tag = "4")]
        pub trailing_comments: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(string, repeated, tag = "6")]
        pub leading_detached_comments: ::prost::alloc::vec::Vec<
            ::prost::alloc::string::String,
        >,
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratedCodeInfo {
    #[prost(message, repeated, tag = "1")]
    pub annotation: ::prost::alloc::vec::Vec<generated_code_info::Annotation>,
}
/// Nested message and enum types in `GeneratedCodeInfo`.
pub mod generated_code_info {
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Annotation {
        #[prost(int32, repeated, tag = "1")]
        pub path: ::prost::alloc::vec::Vec<i32>,
        #[prost(string, optional, tag = "2")]
        pub source_file: ::core::option::Option<::prost::alloc::string::String>,
        #[prost(int32, optional, tag = "3")]
        pub begin: ::core::option::Option<i32>,
        #[prost(int32, optional, tag = "4")]
        pub end: ::core::option::Option<i32>,
        #[prost(enumeration = "annotation::Semantic", optional, tag = "5")]
        pub semantic: ::core::option::Option<i32>,
    }
    /// Nested message and enum types in `Annotation`.
    pub mod annotation {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Semantic {
            None = 0,
            Set = 1,
            Alias = 2,
        }
        impl Semantic {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::None => "NONE",
                    Self::Set => "SET",
                    Self::Alias => "ALIAS",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "NONE" => Some(Self::None),
                    "SET" => Some(Self::Set),
                    "ALIAS" => Some(Self::Alias),
                    _ => None,
                }
            }
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Edition {
    Unknown = 0,
    Legacy = 900,
    Proto2 = 998,
    Proto3 = 999,
    Edition2023 = 1000,
    Edition2024 = 1001,
    Edition1TestOnly = 1,
    Edition2TestOnly = 2,
    Edition99997TestOnly = 99997,
    Edition99998TestOnly = 99998,
    Edition99999TestOnly = 99999,
    Max = 2147483647,
}
impl Edition {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "EDITION_UNKNOWN",
            Self::Legacy => "EDITION_LEGACY",
            Self::Proto2 => "EDITION_PROTO2",
            Self::Proto3 => "EDITION_PROTO3",
            Self::Edition2023 => "EDITION_2023",
            Self::Edition2024 => "EDITION_2024",
            Self::Edition1TestOnly => "EDITION_1_TEST_ONLY",
            Self::Edition2TestOnly => "EDITION_2_TEST_ONLY",
            Self::Edition99997TestOnly => "EDITION_99997_TEST_ONLY",
            Self::Edition99998TestOnly => "EDITION_99998_TEST_ONLY",
            Self::Edition99999TestOnly => "EDITION_99999_TEST_ONLY",
            Self::Max => "EDITION_MAX",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "EDITION_UNKNOWN" => Some(Self::Unknown),
            "EDITION_LEGACY" => Some(Self::Legacy),
            "EDITION_PROTO2" => Some(Self::Proto2),
            "EDITION_PROTO3" => Some(Self::Proto3),
            "EDITION_2023" => Some(Self::Edition2023),
            "EDITION_2024" => Some(Self::Edition2024),
            "EDITION_1_TEST_ONLY" => Some(Self::Edition1TestOnly),
            "EDITION_2_TEST_ONLY" => Some(Self::Edition2TestOnly),
            "EDITION_99997_TEST_ONLY" => Some(Self::Edition99997TestOnly),
            "EDITION_99998_TEST_ONLY" => Some(Self::Edition99998TestOnly),
            "EDITION_99999_TEST_ONLY" => Some(Self::Edition99999TestOnly),
            "EDITION_MAX" => Some(Self::Max),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Duration {
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Empty {}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct FieldMask {
    #[prost(string, repeated, tag = "1")]
    pub paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Struct {
    #[prost(map = "string, message", tag = "1")]
    pub fields: ::std::collections::HashMap<::prost::alloc::string::String, Value>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Value {
    #[prost(oneof = "value::Kind", tags = "1, 2, 3, 4, 5, 6")]
    pub kind: ::core::option::Option<value::Kind>,
}
/// Nested message and enum types in `Value`.
pub mod value {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(enumeration = "super::NullValue", tag = "1")]
        NullValue(i32),
        #[prost(double, tag = "2")]
        NumberValue(f64),
        #[prost(string, tag = "3")]
        StringValue(::prost::alloc::string::String),
        #[prost(bool, tag = "4")]
        BoolValue(bool),
        #[prost(message, tag = "5")]
        StructValue(super::Struct),
        #[prost(message, tag = "6")]
        ListValue(super::ListValue),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListValue {
    #[prost(message, repeated, tag = "1")]
    pub values: ::prost::alloc::vec::Vec<Value>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum NullValue {
    NullValue = 0,
}
impl NullValue {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NullValue => "NULL_VALUE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NULL_VALUE" => Some(Self::NullValue),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Timestamp {
    #[prost(int64, tag = "1")]
    pub seconds: i64,
    #[prost(int32, tag = "2")]
    pub nanos: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DoubleValue {
    #[prost(double, tag = "1")]
    pub value: f64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FloatValue {
    #[prost(float, tag = "1")]
    pub value: f32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Int64Value {
    #[prost(int64, tag = "1")]
    pub value: i64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt64Value {
    #[prost(uint64, tag = "1")]
    pub value: u64,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Int32Value {
    #[prost(int32, tag = "1")]
    pub value: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct UInt32Value {
    #[prost(uint32, tag = "1")]
    pub value: u32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BoolValue {
    #[prost(bool, tag = "1")]
    pub value: bool,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StringValue {
    #[prost(string, tag = "1")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BytesValue {
    #[prost(bytes = "bytes", tag = "1")]
    pub value: ::prost::bytes::Bytes,
}
